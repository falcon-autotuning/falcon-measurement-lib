name: Generate, package, and publish release

permissions:
  contents: write

on:
  workflow_dispatch:
  push:
    branches:
      - master

jobs:
  generate-and-release:
    runs-on: ubuntu-latest
    env:
      OUT_DIR: generated
      VERSION_FILE: VERSION

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Lua 5.4 and prepare PATH
        run: |
          sudo apt-get update
          sudo apt-get install -y lua5.4 liblua5.4-dev luarocks build-essential make libreadline-dev tar gzip
          mkdir -p ./ci-bin
          ln -sf /usr/bin/lua5.4 ./ci-bin/lua
          ln -sf /usr/bin/luac5.4 ./ci-bin/luac
          ln -sf $(which luarocks) ./ci-bin/luarocks
          echo "$PWD/ci-bin" >> $GITHUB_PATH
          lua -v
          luarocks --version
        shell: bash

      - name: Run Makefile to generate and package
        run: |
          make all
        shell: bash

      - name: Show generated tree (debug)
        run: |
          echo "generated/ directory listing:"
          ls -la generated || true
          echo "root tarballs:"
          ls -la *.tar.gz *.sha256 || true
        shell: bash

      - name: Read version file
        id: get_version
        run: |
          if [ ! -f "$VERSION_FILE" ]; then
            echo "VERSION file missing"
            exit 1
          fi
          VERSION="$(cat $VERSION_FILE | tr -d '[:space:]')"
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "Found VERSION=$VERSION"
        shell: bash

      - name: Create combined generated tarball
        run: |
          tar -czf generated-${{ env.VERSION }}.tar.gz -C "${{ env.OUT_DIR }}" .
          ls -la generated-${{ env.VERSION }}.tar.gz || true
        shell: bash

      - name: Ensure package files exist
        run: |
          set -e
          echo "Looking for expected package files (based on VERSION=${{ env.VERSION }})"
          for f in lua-lib-${{ env.VERSION }}.tar.gz go-types-${{ env.VERSION }}.tar.gz emmy-headers-${{ env.VERSION }}.tar.gz generated-${{ env.VERSION }}.tar.gz; do
            if [ ! -f "$f" ]; then
              echo "Missing expected file: $f"
              ls -la || true
              exit 1
            fi
          done
        shell: bash
      - name: Remove existing release for this tag (if any)
        uses: actions/github-script@v6
        env:
          VERSION: ${{ env.VERSION }}
        with:
          script: |
            const tag = `v${process.env.VERSION}`;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            try {
              const existing = await github.rest.repos.getReleaseByTag({
                owner,
                repo,
                tag,
              });
              console.log(`Found existing release id=${existing.data.id} for tag ${tag}, deleting it...`);
              await github.rest.repos.deleteRelease({
                owner,
                repo,
                release_id: existing.data.id,
              });
              console.log('Release deleted.');
            } catch (err) {
              if (err.status === 404) {
                console.log(`No existing release for tag ${tag}.`);
              } else {
                // Re-throw other errors so the job fails and you can inspect the log
                throw err;
              }
            }

      - name: Create GitHub release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ env.VERSION }}
          release_name: Release v${{ env.VERSION }}
          body: |
            Automated generated artifacts for version v${{ env.VERSION }}.
            This release contains generated runtime Lua modules, Emmy headers, Go types, and teal templates.
          draft: false
          prerelease: false

      - name: Upload lua package asset (official action)
        uses: actions/upload-release-asset@v1
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: lua-lib-${{ env.VERSION }}.tar.gz
          asset_name: lua-lib-${{ env.VERSION }}.tar.gz
          asset_content_type: application/gzip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload go package asset (official action)
        uses: actions/upload-release-asset@v1
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: go-types-${{ env.VERSION }}.tar.gz
          asset_name: go-types-${{ env.VERSION }}.tar.gz
          asset_content_type: application/gzip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload emmy package asset (official action)
        uses: actions/upload-release-asset@v1
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: emmy-headers-${{ env.VERSION }}.tar.gz
          asset_name: emmy-headers-${{ env.VERSION }}.tar.gz
          asset_content_type: application/gzip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload full generated tarball (official action)
        uses: actions/upload-release-asset@v1
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: generated-${{ env.VERSION }}.tar.gz
          asset_name: generated-${{ env.VERSION }}.tar.gz
          asset_content_type: application/gzip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Optional alternative: If your enterprise blocks marketplace actions,
      # comment out the official upload steps above and use the curl-based upload below.
      # This uses the upload_url output from create_release and the REST API directly.
      # - name: Upload assets via curl (alternative)
      #   run: |
      #     UPLOAD_URL="${{ steps.create_release.outputs.upload_url }}"
      #     # strip the template suffix like {?name,label}
      #     UPLOAD_URL="${UPLOAD_URL%\{*}"
      #     for file in lua-lib-${{ env.VERSION }}.tar.gz go-types-${{ env.VERSION }}.tar.gz emmy-headers-${{ env.VERSION }}.tar.gz generated-${{ env.VERSION }}.tar.gz; do
      #       echo "Uploading $file"
      #       curl -s -X POST \
      #         -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
      #         -H "Content-Type: application/gzip" \
      #         --data-binary @"$file" \
      #         "$UPLOAD_URL?name=$(basename "$file")"
      #     done
      #   shell: bash
