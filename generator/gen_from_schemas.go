// generator/gen_from_schemas.go
//
// Usage:
//
//	go run gen_from_schemas.go <lib-schemas-dir> <script-schemas-dir> <out-dir>
//
// Example:
//
//	go run gen_from_schemas.go ../schemas/lib ../schemas/scripts ../generated
//
// This program:
// - Reads JSON schemas from lib and scripts directories
// - Collects reusable definitions from lib schemas
// - Generates Go structs (generated/go-types/*.go) for definitions and script contexts
// - Generates Emmy/Lua header files (generated/emmy/*.lua) for script schemas
//
// Note: this is a straightforward generator; it implements a useful subset of JSON Schema:
//   - types: number, integer, string, boolean, array, object
//   - additionalProperties -> map[string]T for script schemas
//   - $ref only in the simple form "../lib/filename.json#/definitions/Name"
package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"sort"
	"strings"
)

type Raw = map[string]interface{}

func must(err error) {
	if err != nil {
		panic(err)
	}
}

func readJSONFilesFromDir(dir string) ([]Raw, error) {
	files, err := ioutil.ReadDir(dir)
	if err != nil {
		return nil, err
	}
	out := []Raw{}
	for _, f := range files {
		if f.IsDir() {
			continue
		}
		if !strings.HasSuffix(f.Name(), ".json") {
			continue
		}
		full := filepath.Join(dir, f.Name())
		b, err := ioutil.ReadFile(full)
		if err != nil {
			return nil, err
		}
		var r Raw
		if err := json.Unmarshal(b, &r); err != nil {
			return nil, fmt.Errorf("parsing %s: %w", full, err)
		}
		out = append(out, r)
	}
	return out, nil
}

func asMap(v interface{}) map[string]interface{} {
	if v == nil {
		return nil
	}
	if m, ok := v.(map[string]interface{}); ok {
		return m
	}
	return nil
}

func asString(v interface{}) string {
	if v == nil {
		return ""
	}
	if s, ok := v.(string); ok {
		return s
	}
	return ""
}

func titleCase(s string) string {
	if s == "" {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

func goTypeFromSchemaType(prop map[string]interface{}) string {
	t := asString(prop["type"])
	switch t {
	case "number":
		return "float64"
	case "integer":
		return "int"
	case "string":
		return "string"
	case "boolean":
		return "bool"
	case "object":
		// map[string]Domain or generic map
		if add := prop["additionalProperties"]; add != nil {
			if refMap, ok := asMap(add); ok {
				if ref := asString(refMap["$ref"]); ref != "" {
					parts := strings.Split(ref, "/")
					return "map[string]" + parts[len(parts)-1]
				}
			}
		}
		return "map[string]interface{}"
	case "array":
		items := asMap(prop["items"])
		if items != nil {
			if ref := asString(items["$ref"]); ref != "" {
				parts := strings.Split(ref, "/")
				return "[]" + parts[len(parts)-1]
			}
			// simple item types fallback
			if it := asString(items["type"]); it != "" {
				switch it {
				case "string":
					return "[]string"
				case "number":
					return "[]float64"
				case "integer":
					return "[]int"
				default:
					return "[]interface{}"
				}
			}
			return "[]interface{}"
		}
		return "[]interface{}"
	default:
		return "interface{}"
	}
}

func collectDefs(libSchemas []Raw) map[string]map[string]interface{} {
	defs := map[string]map[string]interface{}{}
	for _, s := range libSchemas {
		if d := asMap(s["definitions"]); d != nil {
			for k, v := range d {
				if mm := asMap(v); mm != nil {
					defs[k] = mm
				}
			}
		}
	}
	return defs
}

func generateGoTypes(defs map[string]map[string]interface{}, scripts []Raw, outDir string) error {
	// produce a single Go file for all types
	var b strings.Builder
	b.WriteString("// Code generated by gen_from_schemas.go â€” DO NOT EDIT\n\npackage generated\n\nimport \"encoding/json\"\n\n")

	// definitions
	names := []string{}
	for n := range defs {
		names = append(names, n)
	}
	sort.Strings(names)
	for _, n := range names {
		def := defs[n]
		b.WriteString(fmt.Sprintf("// %s: %s\n", n, asString(def["description"])))
		b.WriteString(fmt.Sprintf("type %s struct {\n", n))
		if props := asMap(def["properties"]); props != nil {
			propKeys := []string{}
			for pk := range props {
				propKeys = append(propKeys, pk)
			}
			sort.Strings(propKeys)
			for _, pk := range propKeys {
				pp := asMap(props[pk])
				gtype := goTypeFromSchemaType(pp)
				fieldName := titleCase(pk)
				tag := fmt.Sprintf("`json:\"%s,omitempty\"`", pk)
				b.WriteString(fmt.Sprintf("    %s %s %s // %s\n", fieldName, gtype, tag, asString(pp["description"])))
			}
		}
		b.WriteString("}\n\n")
	}

	// For each script produce a struct named after Title or filename
	for _, s := range scripts {
		title := asString(s["title"])
		if title == "" {
			// fallback: attempt to derive from $id or filename
			title = "ScriptContext"
		}
		structName := title
		structName = strings.ReplaceAll(structName, " ", "_")
		structName = strings.ReplaceAll(structName, "-", "_")
		b.WriteString(fmt.Sprintf("// %s generated from schema\n", structName))
		b.WriteString(fmt.Sprintf("type %s struct {\n", structName))
		if props := asMap(s["properties"]); props != nil {
			propKeys := []string{}
			for pk := range props {
				propKeys = append(propKeys, pk)
			}
			sort.Strings(propKeys)
			for _, pk := range propKeys {
				pp := asMap(props[pk])
				gtype := goTypeFromSchemaType(pp)
				fieldName := titleCase(pk)
				tag := fmt.Sprintf("`json:\"%s,omitempty\"`", pk)
				b.WriteString(fmt.Sprintf("    %s %s %s // %s\n", fieldName, gtype, tag, asString(pp["description"])))
			}
		}
		b.WriteString("}\n\n")
		// ToMap helper
		b.WriteString(fmt.Sprintf("func (rc %s) ToMap() (map[string]interface{}, error) {\n", structName))
		b.WriteString("    b, err := json.Marshal(rc)\n")
		b.WriteString("    if err != nil { return nil, err }\n")
		b.WriteString("    var m map[string]interface{}\n")
		b.WriteString("    if err := json.Unmarshal(b, &m); err != nil { return nil, err }\n")
		b.WriteString("    return m, nil\n")
		b.WriteString("}\n\n")
	}

	// Helper methods for x-methods (simple: only InstrumentTarget.serialize handled)
	// If InstrumentTarget exists, add a Serialize method (simple non-pointer implementation)
	if _, ok := defs["InstrumentTarget"]; ok {
		b.WriteString("// Generated helper methods\n")
		b.WriteString("import \"fmt\"\n\n")
		b.WriteString("func (t InstrumentTarget) Serialize() string {\n")
		b.WriteString("    if t.Channel != 0 {\n")
		b.WriteString("        return fmt.Sprintf(\"%s:%d\", t.Id, t.Channel)\n")
		b.WriteString("    }\n")
		b.WriteString("    return t.Id\n")
		b.WriteString("}\n")
	}

	// write file
	os.MkdirAll(path.Join(outDir, "go-types"), 0755)
	outFile := path.Join(outDir, "go-types", "generated_runtime_types.go")
	return ioutil.WriteFile(outFile, []byte(b.String()), 0644)
}

func emitEmmyDefs(defs map[string]map[string]interface{}, outDir string) error {
	var b strings.Builder
	b.WriteString("---@meta\n\n")
	names := []string{}
	for n := range defs {
		names = append(names, n)
	}
	sort.Strings(names)
	for _, n := range names {
		def := defs[n]
		b.WriteString(fmt.Sprintf("--- %s\n", asString(def["description"])))
		b.WriteString(fmt.Sprintf("@class %s\n", n))
		if props := asMap(def["properties"]); props != nil {
			keys := []string{}
			for k := range props {
				keys = append(keys, k)
			}
			sort.Strings(keys)
			for _, pk := range keys {
				pp := asMap(props[pk])
				jsType := asString(pp["type"])
				emmyType := "any"
				switch jsType {
				case "number":
					emmyType = "number"
				case "integer":
					emmyType = "integer"
				case "string":
					emmyType = "string"
				case "array":
					emmyType = "any[]"
				case "object":
					emmyType = "table"
				}
				b.WriteString(fmt.Sprintf("@field %s %s %s\n", pk, emmyType, asString(pp["description"])))
			}
		}
		// x-methods
		if xm := def["x-methods"]; xm != nil {
			if arr, ok := xm.([]interface{}); ok {
				for _, m := range arr {
					if mm := asMap(m); mm != nil {
						b.WriteString(fmt.Sprintf("--- Method: %s - %s\n", asString(mm["name"]), asString(mm["signature"])))
						b.WriteString(fmt.Sprintf("--- %s\n", asString(mm["description"])))
					}
				}
			}
		}
		b.WriteString("\n")
	}
	os.MkdirAll(path.Join(outDir, "emmy"), 0755)
	return ioutil.WriteFile(path.Join(outDir, "emmy", "defs_emmy.lua"), []byte(b.String()), 0644)
}

func emitEmmyScripts(scripts []Raw, outDir string) error {
	os.MkdirAll(path.Join(outDir, "emmy"), 0755)
	for _, s := range scripts {
		title := asString(s["title"])
		if title == "" {
			title = "ScriptContext"
		}
		// make safe filename
		name := strings.ToLower(strings.ReplaceAll(title, " ", "_"))
		var b strings.Builder
		b.WriteString("---@meta\n\n")
		b.WriteString(fmt.Sprintf("--- %s\n", asString(s["description"])))
		b.WriteString(fmt.Sprintf("@class %s\n", title))
		if props := asMap(s["properties"]); props != nil {
			keys := []string{}
			for k := range props {
				keys = append(keys, k)
			}
			sort.Strings(keys)
			for _, pk := range keys {
				pp := asMap(props[pk])
				jsType := asString(pp["type"])
				emmyType := "any"
				switch jsType {
				case "number":
					emmyType = "number"
				case "integer":
					emmyType = "integer"
				case "string":
					emmyType = "string"
				case "array":
					if items := asMap(pp["items"]); items != nil {
						if ref := asString(items["$ref"]); ref != "" {
							parts := strings.Split(ref, "/")
							emmyType = parts[len(parts)-1] + "[]"
						} else {
							emmyType = "any[]"
						}
					} else {
						emmyType = "any[]"
					}
				case "object":
					emmyType = "table"
				}
				b.WriteString(fmt.Sprintf("@field %s %s %s\n", pk, emmyType, asString(pp["description"])))
			}
		}
		// also reference defs for LSP hints by including defs_emmy.lua (editor will pick up both files)
		fn := path.Join(outDir, "emmy", fmt.Sprintf("%s_emmy.lua", name))
		if err := ioutil.WriteFile(fn, []byte(b.String()), 0644); err != nil {
			return err
		}
	}
	return nil
}

func main() {
	if len(os.Args) < 4 {
		fmt.Println("usage: gen_from_schemas <lib-schemas-dir> <script-schemas-dir> <out-dir>")
		os.Exit(2)
	}
	libDir := os.Args[1]
	scriptsDir := os.Args[2]
	outDir := os.Args[3]

	libSchemas, err := readJSONFilesFromDir(libDir)
	must(err)
	scriptSchemas, err := readJSONFilesFromDir(scriptsDir)
	must(err)

	defs := collectDefs(libSchemas)

	// Generate Go types
	if err := generateGoTypes(defs, scriptSchemas, outDir); err != nil {
		panic(err)
	}

	// Generate Emmy defs
	if err := emitEmmyDefs(defs, outDir); err != nil {
		panic(err)
	}

	// Generate Emmy per-script
	if err := emitEmmyScripts(scriptSchemas, outDir); err != nil {
		panic(err)
	}

	fmt.Println("generator: wrote outputs to", outDir)
}
